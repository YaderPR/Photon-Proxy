use anyhow::Result;
use crate::proxy_engine::ProxyAdapter;
use log::info;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::os::unix::io::AsRawFd;
use socket2::{Socket, Domain, Type, Protocol};
use tokio::net::{TcpListener, UdpSocket, TcpSocket};

/// The firewall mark applied to all egress packets generated by the proxy
/// to bypass the TPROXY iptables rules and avoid infinite routing loops.
pub const PROXY_FWMARK: u32 = 0xfe;

pub struct LinuxTproxyAdapter {
    local_port: u16,
    tcp_listener: Option<TcpListener>,
    udp_socket: Option<UdpSocket>,
}

impl LinuxTproxyAdapter {
    pub fn new(local_port: u16) -> Self {
        Self { 
            local_port,
            tcp_listener: None,
            udp_socket: None,
        }
    }

    fn create_transparent_tcp_listener(addr: SocketAddr) -> Result<TcpListener> {
        let domain = if addr.is_ipv4() { Domain::IPV4 } else { Domain::IPV6 };
        let socket = Socket::new(domain, Type::STREAM, Some(Protocol::TCP))?;
        
        socket.set_reuse_address(true)?;
        set_transparent(socket.as_raw_fd(), addr.is_ipv4())?;

        socket.bind(&addr.into())?;
        socket.listen(1024)?;
        socket.set_nonblocking(true)?;

        Ok(TcpListener::from_std(socket.into())?)
    }

    fn create_transparent_udp_socket(addr: SocketAddr) -> Result<UdpSocket> {
        let domain = if addr.is_ipv4() { Domain::IPV4 } else { Domain::IPV6 };
        let socket = Socket::new(domain, Type::DGRAM, Some(Protocol::UDP))?;
        
        socket.set_reuse_address(true)?;
        set_transparent(socket.as_raw_fd(), addr.is_ipv4())?;

        socket.bind(&addr.into())?;
        socket.set_nonblocking(true)?;

        Ok(UdpSocket::from_std(socket.into())?)
    }
}

/// Sets the IP_TRANSPARENT socket option
fn set_transparent(fd: std::os::unix::io::RawFd, is_ipv4: bool) -> Result<()> {
    let optval: libc::c_int = 1;
    let ret = unsafe {
        if is_ipv4 {
            libc::setsockopt(fd, libc::SOL_IP, libc::IP_TRANSPARENT, &optval as *const _ as *const libc::c_void, std::mem::size_of_val(&optval) as libc::socklen_t)
        } else {
            libc::setsockopt(fd, libc::SOL_IPV6, libc::IPV6_TRANSPARENT, &optval as *const _ as *const libc::c_void, std::mem::size_of_val(&optval) as libc::socklen_t)
        }
    };
    if ret < 0 {
        return Err(std::io::Error::last_os_error().into());
    }
    Ok(())
}

/// Sets the SO_MARK socket option
fn set_fwmark(fd: std::os::unix::io::RawFd, mark: u32) -> Result<()> {
    let optval: libc::c_int = mark as libc::c_int;
    let ret = unsafe {
        libc::setsockopt(fd, libc::SOL_SOCKET, libc::SO_MARK, &optval as *const _ as *const libc::c_void, std::mem::size_of_val(&optval) as libc::socklen_t)
    };
    if ret < 0 {
        return Err(std::io::Error::last_os_error().into());
    }
    Ok(())
}

/// Helper function to create a new tokio TcpSocket with the proxy firewall mark applied.
/// This must be used by the proxy engine whenever it establishes an outbound connection to the real destination.
pub fn create_marked_tcp_socket(dest_addr: &SocketAddr) -> Result<TcpSocket> {
    let socket = if dest_addr.is_ipv4() {
        TcpSocket::new_v4()?
    } else {
        TcpSocket::new_v6()?
    };

    set_fwmark(socket.as_raw_fd(), PROXY_FWMARK)?;
    Ok(socket)
}

/// Helper function to create a new tokio UdpSocket with the proxy firewall mark applied.
pub fn create_marked_udp_socket(dest_addr: &SocketAddr) -> Result<UdpSocket> {
    let domain = if dest_addr.is_ipv4() { Domain::IPV4 } else { Domain::IPV6 };
    let socket = Socket::new(domain, Type::DGRAM, Some(Protocol::UDP))?;
    
    set_fwmark(socket.as_raw_fd(), PROXY_FWMARK)?;
    socket.set_nonblocking(true)?;
    Ok(UdpSocket::from_std(socket.into())?)
}

impl ProxyAdapter for LinuxTproxyAdapter {
    async fn start(&mut self) -> Result<()> {
        info!("Starting LinuxTproxyAdapter on port {}", self.local_port);
        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), self.local_port);
        
        self.tcp_listener = Some(Self::create_transparent_tcp_listener(addr)?);
        self.udp_socket = Some(Self::create_transparent_udp_socket(addr)?);
        
        info!("TPROXY listeners successfully bound to {}", addr);
        
        crate::proxy_engine::system_rules::setup_tproxy_rules(self.local_port, PROXY_FWMARK).await?;
        
        Ok(())
    }

    async fn stop(&mut self) -> Result<()> {
        info!("Stopping LinuxTproxyAdapter");
        self.tcp_listener = None;
        self.udp_socket = None;
        
        crate::proxy_engine::system_rules::cleanup_tproxy_rules().await?;

        Ok(())
    }
}
