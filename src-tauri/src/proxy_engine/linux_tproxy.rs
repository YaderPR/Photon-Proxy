use anyhow::Result;
use crate::proxy_engine::ProxyAdapter;
use log::info;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::os::unix::io::AsRawFd;
use socket2::{Socket, Domain, Type, Protocol};
use tokio::net::{TcpListener, UdpSocket, TcpSocket, TcpStream};
use crate::proxy_engine::upstream_relay::{UpstreamProtocol, UpstreamClient};
use crate::proxy_engine::upstream_relay::socks5::Socks5Client;
use crate::proxy_engine::upstream_relay::http_proxy::HttpProxyClient;

/// The firewall mark applied to all egress packets generated by the proxy
/// to bypass the TPROXY iptables rules and avoid infinite routing loops.
pub const PROXY_FWMARK: u32 = 0xfe;

pub struct LinuxTproxyAdapter {
    local_port: u16,
    upstream: UpstreamProtocol,
    tcp_listener: Option<TcpListener>,
    udp_socket: Option<UdpSocket>,
}

impl LinuxTproxyAdapter {
    pub fn new(local_port: u16, upstream: UpstreamProtocol) -> Self {
        Self { 
            local_port,
            upstream,
            tcp_listener: None,
            udp_socket: None,
        }
    }

    fn create_transparent_tcp_listener(addr: SocketAddr) -> Result<TcpListener> {
        let domain = if addr.is_ipv4() { Domain::IPV4 } else { Domain::IPV6 };
        let socket = Socket::new(domain, Type::STREAM, Some(Protocol::TCP))?;
        
        socket.set_reuse_address(true)?;
        set_transparent(socket.as_raw_fd(), addr.is_ipv4())?;

        socket.bind(&addr.into())?;
        socket.listen(1024)?;
        socket.set_nonblocking(true)?;

        Ok(TcpListener::from_std(socket.into())?)
    }

    fn create_transparent_udp_socket(addr: SocketAddr) -> Result<UdpSocket> {
        let domain = if addr.is_ipv4() { Domain::IPV4 } else { Domain::IPV6 };
        let socket = Socket::new(domain, Type::DGRAM, Some(Protocol::UDP))?;
        
        socket.set_reuse_address(true)?;
        set_transparent(socket.as_raw_fd(), addr.is_ipv4())?;

        socket.bind(&addr.into())?;
        socket.set_nonblocking(true)?;

        Ok(UdpSocket::from_std(socket.into())?)
    }
}

/// Sets the IP_TRANSPARENT socket option
fn set_transparent(fd: std::os::unix::io::RawFd, is_ipv4: bool) -> Result<()> {
    let optval: libc::c_int = 1;
    let ret = unsafe {
        if is_ipv4 {
            libc::setsockopt(fd, libc::SOL_IP, libc::IP_TRANSPARENT, &optval as *const _ as *const libc::c_void, std::mem::size_of_val(&optval) as libc::socklen_t)
        } else {
            libc::setsockopt(fd, libc::SOL_IPV6, libc::IPV6_TRANSPARENT, &optval as *const _ as *const libc::c_void, std::mem::size_of_val(&optval) as libc::socklen_t)
        }
    };
    if ret < 0 {
        return Err(std::io::Error::last_os_error().into());
    }
    Ok(())
}

/// Sets the SO_MARK socket option
fn set_fwmark(fd: std::os::unix::io::RawFd, mark: u32) -> Result<()> {
    let optval: libc::c_int = mark as libc::c_int;
    let ret = unsafe {
        libc::setsockopt(fd, libc::SOL_SOCKET, libc::SO_MARK, &optval as *const _ as *const libc::c_void, std::mem::size_of_val(&optval) as libc::socklen_t)
    };
    if ret < 0 {
        return Err(std::io::Error::last_os_error().into());
    }
    Ok(())
}

/// Helper function to create a new tokio TcpSocket with the proxy firewall mark applied.
/// This must be used by the proxy engine whenever it establishes an outbound connection to the real destination.
pub fn create_marked_tcp_socket(dest_addr: &SocketAddr) -> Result<TcpSocket> {
    let socket = if dest_addr.is_ipv4() {
        TcpSocket::new_v4()?
    } else {
        TcpSocket::new_v6()?
    };

    set_fwmark(socket.as_raw_fd(), PROXY_FWMARK)?;
    Ok(socket)
}

/// Helper function to create a new tokio UdpSocket with the proxy firewall mark applied.
pub fn create_marked_udp_socket(dest_addr: &SocketAddr) -> Result<UdpSocket> {
    let domain = if dest_addr.is_ipv4() { Domain::IPV4 } else { Domain::IPV6 };
    let socket = Socket::new(domain, Type::DGRAM, Some(Protocol::UDP))?;
    
    set_fwmark(socket.as_raw_fd(), PROXY_FWMARK)?;
    socket.set_nonblocking(true)?;
    Ok(UdpSocket::from_std(socket.into())?)
}

impl ProxyAdapter for LinuxTproxyAdapter {
    async fn start(&mut self) -> Result<()> {
        info!("Starting LinuxTproxyAdapter on port {}", self.local_port);
        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), self.local_port);
        
        self.tcp_listener = Some(Self::create_transparent_tcp_listener(addr)?);
        self.udp_socket = Some(Self::create_transparent_udp_socket(addr)?);
        
        info!("TPROXY listeners successfully bound to {}", addr);
        
        crate::proxy_engine::system_rules::setup_tproxy_rules(self.local_port, PROXY_FWMARK).await?;
        
        /* Start TCP accept loop in background */
        if let Some(listener) = self.tcp_listener.take() {
            let upstream_cfg = self.upstream.clone();
            tokio::spawn(async move {
                Self::tcp_accept_loop(listener, upstream_cfg).await;
            });
        }

        Ok(())
    }

    async fn stop(&mut self) -> Result<()> {
        info!("Stopping LinuxTproxyAdapter");
        self.tcp_listener = None;
        self.udp_socket = None;
        
        crate::proxy_engine::system_rules::cleanup_tproxy_rules().await?;

        Ok(())
    }
}

impl LinuxTproxyAdapter {
    async fn tcp_accept_loop(listener: TcpListener, upstream: UpstreamProtocol) {
        info!("TPROXY TCP accept loop started");
        loop {
            match listener.accept().await {
                Ok((mut client_stream, src_addr)) => {
                    // Because of TPROXY, local_addr() actually gives us the original REAl destination
                    let target_addr = match client_stream.local_addr() {
                        Ok(addr) => addr,
                        Err(e) => {
                            log::error!("Failed to get target address from transparent socket: {}", e);
                            continue;
                        }
                    };
                    log::debug!("Intercepted TCP connection from {} to target {}", src_addr, target_addr);

                    let up_cfg = upstream.clone();
                    tokio::spawn(async move {
                        if let Err(e) = Self::handle_tcp_connection(&mut client_stream, &target_addr, &up_cfg).await {
                            log::error!("TCP connection handler error for {}: {}", target_addr, e);
                        }
                    });
                }
                Err(e) => {
                    log::error!("TPROXY TCP accept failed: {}", e);
                }
            }
        }
    }

    async fn handle_tcp_connection(
        client_stream: &mut tokio::net::TcpStream, 
        target_addr: &SocketAddr, 
        upstream: &UpstreamProtocol
    ) -> Result<()> {
        // 1. Establish connection to the proxy/relay
        let mut server_stream = match upstream {
            UpstreamProtocol::Direct => {
                let socket = create_marked_tcp_socket(target_addr)?;
                socket.connect(*target_addr).await?
            }
            UpstreamProtocol::Socks5 { server, username, password } => {
                let u = username.as_deref();
                let p = password.as_deref();
                Socks5Client.connect(target_addr, server, u, p).await?
            }
            UpstreamProtocol::HttpProxy { server, username, password } => {
                let u = username.as_deref();
                let p = password.as_deref();
                HttpProxyClient.connect(target_addr, server, u, p).await?
            }
        };

        log::debug!("Upstream tunnel established for {}", target_addr);

        // 2. Splice them together at kernel level (Zero-Copy)
        let (tx, rx) = crate::proxy_engine::zero_copy::bidirectional_splice(client_stream, &mut server_stream).await?;
        
        log::debug!("Connection terminating for {}. TX: {} bytes, RX: {} bytes", target_addr, tx, rx);
        Ok(())
    }
}
