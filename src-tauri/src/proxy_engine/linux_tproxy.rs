use crate::proxy_engine::upstream_relay::http_proxy::HttpProxyClient;
use crate::proxy_engine::upstream_relay::socks5::Socks5Client;
use crate::proxy_engine::upstream_relay::{UpstreamClient, UpstreamProtocol};
use crate::proxy_engine::ProxyAdapter;
use anyhow::Result;
use log::info;
use socket2::{Domain, Protocol, Socket, Type};
use std::collections::HashMap;
use std::net::{IpAddr, Ipv4Addr, SocketAddr, SocketAddrV4, SocketAddrV6};
use std::os::unix::io::AsRawFd;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Duration;
use tokio::io::Interest;
use tokio::net::{TcpListener, TcpSocket, UdpSocket};
use tokio::sync::RwLock;

/// The firewall mark applied to all egress packets generated by the proxy
/// to bypass the TPROXY iptables rules and avoid infinite routing loops.
pub const PROXY_FWMARK: u32 = 0xfe;

#[derive(serde::Serialize, Clone, Debug)]
pub struct LogPayload {
    pub timestamp: String,
    pub level: String,
    pub message: String,
    pub protocol: String,
    pub src: String,
    pub dst: String,
}

pub struct LinuxTproxyAdapter {
    local_port: u16,
    upstream: UpstreamProtocol,
    tcp_listener: Option<TcpListener>,
    udp_socket: Option<Arc<UdpSocket>>,
    app_handle: Option<tauri::AppHandle>,
}

impl LinuxTproxyAdapter {
    pub fn new(local_port: u16, upstream: UpstreamProtocol, app_handle: tauri::AppHandle) -> Self {
        Self {
            local_port,
            upstream,
            tcp_listener: None,
            udp_socket: None,
            app_handle: Some(app_handle),
        }
    }

    fn create_transparent_tcp_listener(addr: SocketAddr) -> Result<TcpListener> {
        let domain = if addr.is_ipv4() {
            Domain::IPV4
        } else {
            Domain::IPV6
        };
        let socket = Socket::new(domain, Type::STREAM, Some(Protocol::TCP))?;

        socket.set_reuse_address(true)?;
        set_transparent(socket.as_raw_fd(), addr.is_ipv4())?;

        socket.bind(&addr.into())?;
        socket.listen(1024)?;
        socket.set_nonblocking(true)?;

        Ok(TcpListener::from_std(socket.into())?)
    }

    fn create_transparent_udp_socket(addr: SocketAddr) -> Result<UdpSocket> {
        let domain = if addr.is_ipv4() {
            Domain::IPV4
        } else {
            Domain::IPV6
        };
        let socket = Socket::new(domain, Type::DGRAM, Some(Protocol::UDP))?;

        socket.set_reuse_address(true)?;
        set_transparent(socket.as_raw_fd(), addr.is_ipv4())?;
        set_recv_orig_dst(socket.as_raw_fd(), addr.is_ipv4())?;

        socket.bind(&addr.into())?;
        socket.set_nonblocking(true)?;

        Ok(UdpSocket::from_std(socket.into())?)
    }
}

/// Sets the IP_RECVORIGDSTADDR socket option to get the real target of a TPROXY UDP packet
fn set_recv_orig_dst(fd: std::os::unix::io::RawFd, is_ipv4: bool) -> Result<()> {
    let optval: libc::c_int = 1;
    let ret = unsafe {
        if is_ipv4 {
            libc::setsockopt(
                fd,
                libc::SOL_IP,
                libc::IP_RECVORIGDSTADDR,
                &optval as *const _ as *const libc::c_void,
                std::mem::size_of_val(&optval) as libc::socklen_t,
            )
        } else {
            libc::setsockopt(
                fd,
                libc::SOL_IPV6,
                libc::IPV6_RECVORIGDSTADDR,
                &optval as *const _ as *const libc::c_void,
                std::mem::size_of_val(&optval) as libc::socklen_t,
            )
        }
    };
    if ret < 0 {
        return Err(std::io::Error::last_os_error().into());
    }
    Ok(())
}

/// Sets the IP_TRANSPARENT socket option
fn set_transparent(fd: std::os::unix::io::RawFd, is_ipv4: bool) -> Result<()> {
    let optval: libc::c_int = 1;
    let ret = unsafe {
        if is_ipv4 {
            libc::setsockopt(
                fd,
                libc::SOL_IP,
                libc::IP_TRANSPARENT,
                &optval as *const _ as *const libc::c_void,
                std::mem::size_of_val(&optval) as libc::socklen_t,
            )
        } else {
            libc::setsockopt(
                fd,
                libc::SOL_IPV6,
                libc::IPV6_TRANSPARENT,
                &optval as *const _ as *const libc::c_void,
                std::mem::size_of_val(&optval) as libc::socklen_t,
            )
        }
    };
    if ret < 0 {
        return Err(std::io::Error::last_os_error().into());
    }
    Ok(())
}

/// Sets the SO_MARK socket option
fn set_fwmark(fd: std::os::unix::io::RawFd, mark: u32) -> Result<()> {
    let optval: libc::c_int = mark as libc::c_int;
    let ret = unsafe {
        libc::setsockopt(
            fd,
            libc::SOL_SOCKET,
            libc::SO_MARK,
            &optval as *const _ as *const libc::c_void,
            std::mem::size_of_val(&optval) as libc::socklen_t,
        )
    };
    if ret < 0 {
        return Err(std::io::Error::last_os_error().into());
    }
    Ok(())
}

/// Helper function to create a new tokio TcpSocket with the proxy firewall mark applied.
/// This must be used by the proxy engine whenever it establishes an outbound connection to the real destination.
pub fn create_marked_tcp_socket(dest_addr: &SocketAddr) -> Result<TcpSocket> {
    let socket = if dest_addr.is_ipv4() {
        TcpSocket::new_v4()?
    } else {
        TcpSocket::new_v6()?
    };

    set_fwmark(socket.as_raw_fd(), PROXY_FWMARK)?;
    Ok(socket)
}

/// Helper function to create a new tokio UdpSocket with the proxy firewall mark applied.
pub fn create_marked_udp_socket(dest_addr: &SocketAddr) -> Result<UdpSocket> {
    let domain = if dest_addr.is_ipv4() {
        Domain::IPV4
    } else {
        Domain::IPV6
    };
    let socket = Socket::new(domain, Type::DGRAM, Some(Protocol::UDP))?;

    set_fwmark(socket.as_raw_fd(), PROXY_FWMARK)?;
    socket.set_nonblocking(true)?;
    Ok(UdpSocket::from_std(socket.into())?)
}

impl ProxyAdapter for LinuxTproxyAdapter {
    async fn start(&mut self, app_handle: tauri::AppHandle) -> Result<()> {
        self.app_handle = Some(app_handle);
        info!("Starting LinuxTproxyAdapter on port {}", self.local_port);
        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::UNSPECIFIED), self.local_port);

        self.tcp_listener = Some(Self::create_transparent_tcp_listener(addr)?);
        self.udp_socket = Some(Arc::new(Self::create_transparent_udp_socket(addr)?));

        info!("TPROXY listeners successfully bound to {}", addr);

        crate::proxy_engine::system_rules::setup_tproxy_rules(self.local_port, PROXY_FWMARK)
            .await?;

        /* Start TCP accept loop in background */
        if let Some(listener) = self.tcp_listener.take() {
            let upstream_cfg = self.upstream.clone();
            let handle = self.app_handle.clone();
            let port = self.local_port;
            tokio::spawn(async move {
                Self::tcp_accept_loop(listener, port, upstream_cfg, handle).await;
            });
        }

        /* Start UDP recv loop in background */
        if let Some(socket) = self.udp_socket.take() {
            let upstream_cfg = self.upstream.clone();
            let handle = self.app_handle.clone();
            tokio::spawn(async move {
                if let Err(e) = Self::udp_recv_loop(socket, upstream_cfg, handle).await {
                    log::error!("UDP receive loop error: {}", e);
                }
            });
        }

        Ok(())
    }

    async fn stop(&mut self) -> Result<()> {
        info!("Stopping LinuxTproxyAdapter");
        self.tcp_listener = None;
        self.udp_socket = None;

        crate::proxy_engine::system_rules::cleanup_tproxy_rules().await?;

        Ok(())
    }
}

impl LinuxTproxyAdapter {
    fn emit_log(
        handle: &Option<tauri::AppHandle>,
        level: &str,
        protocol: &str,
        message: &str,
        src: &str,
        dst: &str,
    ) {
        if let Some(h) = handle {
            use tauri::Emitter;
            let payload = LogPayload {
                timestamp: chrono::Local::now().format("%H:%M:%S").to_string(),
                level: level.to_string(),
                message: message.to_string(),
                protocol: protocol.to_string(),
                src: src.to_string(),
                dst: dst.to_string(),
            };
            let _ = h.emit("proxy-log", payload);
        }
    }

    async fn tcp_accept_loop(
        listener: TcpListener,
        local_port: u16,
        upstream: UpstreamProtocol,
        handle: Option<tauri::AppHandle>,
    ) {
        info!("TPROXY TCP accept loop started");
        loop {
            match listener.accept().await {
                Ok((mut client_stream, src_addr)) => {
                    let mut target_addr = match client_stream.local_addr() {
                        Ok(addr) => addr,
                        Err(e) => {
                            log::error!(
                                "Failed to get target address from transparent socket: {}",
                                e
                            );
                            continue;
                        }
                    };

                    // Handle Docker bridge connections routed via REDIRECT (SO_ORIGINAL_DST)
                    if target_addr.port() == local_port
                        && target_addr.ip() == std::net::Ipv4Addr::new(127, 0, 0, 1)
                    {
                        if let Ok(orig) = get_original_dst(client_stream.as_raw_fd()) {
                            if orig.port() != target_addr.port() || orig.ip() != target_addr.ip() {
                                log::debug!("TCP REDIRECT connection detected. Rewriting target {} to SO_ORIGINAL_DST {}", target_addr, orig);
                                target_addr = orig;
                            }
                        }
                    }

                    Self::emit_log(
                        &handle,
                        "INFO",
                        "TCP",
                        "Intercepted connection",
                        &src_addr.to_string(),
                        &target_addr.to_string(),
                    );

                    let up_cfg = upstream.clone();
                    let handle_clone = handle.clone();
                    tokio::spawn(async move {
                        if let Err(e) = Self::handle_tcp_connection(
                            &mut client_stream,
                            &target_addr,
                            &up_cfg,
                            &handle_clone,
                        )
                        .await
                        {
                            log::error!("TCP connection handler error for {}: {}", target_addr, e);
                            Self::emit_log(
                                &handle_clone,
                                "ERROR",
                                "TCP",
                                &format!("Error: {}", e),
                                &src_addr.to_string(),
                                &target_addr.to_string(),
                            );
                        }
                    });
                }
                Err(e) => {
                    log::error!("TPROXY TCP accept failed: {}", e);
                }
            }
        }
    }

    async fn udp_recv_loop(
        socket: Arc<UdpSocket>,
        upstream: UpstreamProtocol,
        handle: Option<tauri::AppHandle>,
    ) -> Result<()> {
        info!("TPROXY UDP receive loop started");

        let socket_fd = socket.as_raw_fd();
        let sessions: Arc<RwLock<HashMap<SocketAddr, Arc<UdpSession>>>> =
            Arc::new(RwLock::new(HashMap::new()));
        let mut buf = [0u8; 65535];

        // Centralized background cleaner for UDP sessions
        let sessions_cleaner = sessions.clone();
        tokio::spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_secs(30)).await;
                let now = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs();

                let mut session_map = sessions_cleaner.write().await;
                session_map.retain(|_, session| {
                    let last = session.last_activity.load(Ordering::Relaxed);
                    // 120 seconds idle timeout
                    if now - last > 120 {
                        log::debug!("Cleaning up idle UDP session for {}", session.client_addr);
                        false
                    } else {
                        true
                    }
                });
            }
        });

        loop {
            socket.readable().await?;

            // Scope for non-Send types (libc structs)
            let result = socket.try_io(Interest::READABLE, || {
                let mut msg_name: libc::sockaddr_storage = unsafe { std::mem::zeroed() };
                let mut iov = libc::iovec {
                    iov_base: buf.as_mut_ptr() as *mut libc::c_void,
                    iov_len: buf.len(),
                };
                let mut control_buf = [0u8; 128];
                let mut msg = libc::msghdr {
                    msg_name: &mut msg_name as *mut _ as *mut libc::c_void,
                    msg_namelen: std::mem::size_of_val(&msg_name) as u32,
                    msg_iov: &mut iov,
                    msg_iovlen: 1,
                    msg_control: control_buf.as_mut_ptr() as *mut libc::c_void,
                    msg_controllen: control_buf.len() as usize,
                    msg_flags: 0,
                };

                let n = unsafe { libc::recvmsg(socket_fd, &mut msg, 0) };
                if n < 0 {
                    return Err(std::io::Error::last_os_error());
                } else {
                    let n = n as usize;
                    let client_addr = unsafe { sockaddr_to_socketaddr(&msg_name) };
                    let dst_addr = get_orig_dst_from_msg(&msg);

                    match (client_addr, dst_addr) {
                        (Some(c), Some(d)) => Ok(Some((n, c, d))),
                        _ => Ok(None),
                    }
                }
            });

            if let Ok(Some((n, client_addr, dst_addr))) = result {
                // Check if it's a DNS query (Port 53)
                if dst_addr.port() == 53 {
                    log::debug!("Intercepted DNS query from {} to {}", client_addr, dst_addr);

                    let upstream_cfg = upstream.clone();
                    let socket_captured = socket.clone();
                    let query = buf[..n].to_vec();

                    tokio::spawn(async move {
                        match Self::resolve_dns_via_proxy(&query, &upstream_cfg).await {
                            Ok(resp) => {
                                if let Err(e) = send_udp_transparent(
                                    &socket_captured,
                                    &resp,
                                    &client_addr,
                                    &dst_addr,
                                ) {
                                    log::error!(
                                        "Failed to send DNS response back to {}: {}",
                                        client_addr,
                                        e
                                    );
                                }
                            }
                            Err(e) => log::error!("DNS resolving error via proxy: {}", e),
                        }
                    });
                    continue; // DNS handled separately
                }

                let mut session_map = sessions.write().await;
                let session = if let Some(s) = session_map.get(&client_addr) {
                    s.clone()
                } else {
                    let s = Arc::new(
                        UdpSession::new(
                            client_addr,
                            dst_addr,
                            upstream.clone(),
                            socket.clone(),
                            handle.clone(),
                        )
                        .await?,
                    );
                    session_map.insert(client_addr, s.clone());

                    Self::emit_log(
                        &handle,
                        "INFO",
                        "UDP",
                        "New Session",
                        &client_addr.to_string(),
                        &dst_addr.to_string(),
                    );

                    s
                };

                session.send_to_remote(&buf[..n], dst_addr).await?;
            }
        }
    }

    async fn handle_tcp_connection(
        client_stream: &mut tokio::net::TcpStream,
        target_addr: &SocketAddr,
        upstream: &UpstreamProtocol,
        _handle: &Option<tauri::AppHandle>,
    ) -> Result<()> {
        // 1. Establish connection to the proxy/relay
        let mut server_stream = match upstream {
            UpstreamProtocol::Direct => {
                let socket = create_marked_tcp_socket(target_addr)?;
                socket.connect(*target_addr).await?
            }
            UpstreamProtocol::Socks5 {
                server,
                username,
                password,
            } => {
                let u = username.as_deref();
                let p = password.as_deref();
                Socks5Client.connect(target_addr, server, u, p).await?
            }
            UpstreamProtocol::HttpProxy {
                server,
                username,
                password,
            } => {
                let u = username.as_deref();
                let p = password.as_deref();
                HttpProxyClient.connect(target_addr, server, u, p).await?
            }
        };

        log::debug!("Upstream tunnel established for {}", target_addr);

        // 2. Splice them together at kernel level (Zero-Copy)
        let (tx, rx) =
            crate::proxy_engine::zero_copy::bidirectional_splice(client_stream, &mut server_stream)
                .await?;

        log::debug!(
            "TCP Connection closed for {}. TX: {} bytes, RX: {} bytes",
            target_addr,
            tx,
            rx
        );

        log::debug!(
            "Connection terminating for {}. TX: {} bytes, RX: {} bytes",
            target_addr,
            tx,
            rx
        );
        Ok(())
    }

    async fn resolve_dns_via_proxy(query: &[u8], upstream: &UpstreamProtocol) -> Result<Vec<u8>> {
        let dns_addr: SocketAddr = "1.1.1.1:53".parse().unwrap();

        // 1. Connect to Upstream Proxy but targeting 1.1.1.1:53 TCP
        let mut stream = match upstream {
            UpstreamProtocol::Direct => {
                let socket = create_marked_tcp_socket(&dns_addr)?;
                socket.connect(dns_addr).await?
            }
            UpstreamProtocol::Socks5 {
                server,
                username,
                password,
            } => {
                Socks5Client
                    .connect(&dns_addr, server, username.as_deref(), password.as_deref())
                    .await?
            }
            UpstreamProtocol::HttpProxy {
                server,
                username,
                password,
            } => {
                HttpProxyClient
                    .connect(&dns_addr, server, username.as_deref(), password.as_deref())
                    .await?
            }
        };

        // 2. DNS over TCP: Send [Length: u16, Query: ...]
        let mut tcp_query = Vec::with_capacity(query.len() + 2);
        tcp_query.extend_from_slice(&(query.len() as u16).to_be_bytes());
        tcp_query.extend_from_slice(query);

        use tokio::io::{AsyncReadExt, AsyncWriteExt};
        stream.write_all(&tcp_query).await?;

        // 3. Read response [Length: u16, Response: ...]
        let mut len_buf = [0u8; 2];
        stream.read_exact(&mut len_buf).await?;
        let resp_len = u16::from_be_bytes(len_buf) as usize;

        let mut resp = vec![0u8; resp_len];
        stream.read_exact(&mut resp).await?;

        Ok(resp)
    }
}

struct UdpSession {
    client_addr: SocketAddr,
    upstream_socket: Arc<UdpSocket>,
    downstream_socket: Arc<UdpSocket>, // The TPROXY socket to send back to client
    app_handle: Option<tauri::AppHandle>,
    last_activity: Arc<AtomicU64>,
}

impl UdpSession {
    async fn new(
        client_addr: SocketAddr,
        dst_addr: SocketAddr,
        _upstream: UpstreamProtocol,
        downstream: Arc<UdpSocket>,
        handle: Option<tauri::AppHandle>,
    ) -> Result<Self> {
        let socket = Arc::new(create_marked_udp_socket(&dst_addr)?);

        let last_activity = Arc::new(AtomicU64::new(
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
        ));

        let session = Self {
            client_addr,
            upstream_socket: socket,
            downstream_socket: downstream,
            app_handle: handle,
            last_activity,
        };

        // Start listening for responses from remote
        let client_addr_captured = client_addr;
        let upstream_socket_clone = session.upstream_socket.clone();
        let downstream_socket_clone = session.downstream_socket.clone();
        let handle_clone = session.app_handle.clone();
        let last_activity_clone = session.last_activity.clone();

        tokio::spawn(async move {
            let mut buf = [0u8; 65535];
            loop {
                match upstream_socket_clone.recv_from(&mut buf).await {
                    Ok((n, remote_src)) => {
                        // Update activity
                        last_activity_clone.store(
                            std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap_or_default()
                                .as_secs(),
                            Ordering::Relaxed,
                        );

                        if let Err(e) = send_udp_transparent(
                            &downstream_socket_clone,
                            &buf[..n],
                            &client_addr_captured,
                            &remote_src,
                        ) {
                            log::error!(
                                "Failed to relay UDP response to client {}: {}",
                                client_addr_captured,
                                e
                            );
                        }
                    }
                    Err(e) => {
                        log::debug!("UDP Session for {} closed: {}", client_addr_captured, e);
                        LinuxTproxyAdapter::emit_log(
                            &handle_clone,
                            "INFO",
                            "UDP",
                            "Session closed",
                            &client_addr_captured.to_string(),
                            "Remote",
                        );
                        break;
                    }
                }
            }
        });

        Ok(session)
    }

    async fn send_to_remote(&self, data: &[u8], dst_addr: SocketAddr) -> Result<()> {
        // Update activity
        self.last_activity.store(
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs(),
            Ordering::Relaxed,
        );

        self.upstream_socket.send_to(data, &dst_addr).await?;
        Ok(())
    }
}

/// Helper to send a UDP packet back to the client while spoofing the source address
fn send_udp_transparent(
    socket: &UdpSocket,
    data: &[u8],
    client_addr: &SocketAddr,
    spoof_src: &SocketAddr,
) -> Result<()> {
    let fd = socket.as_raw_fd();
    let mut msg_name: libc::sockaddr_storage = unsafe { std::mem::zeroed() };
    let msg_namelen = match client_addr {
        SocketAddr::V4(addr) => {
            let sin: *mut libc::sockaddr_in = &mut msg_name as *mut _ as *mut _;
            unsafe {
                (*sin).sin_family = libc::AF_INET as libc::sa_family_t;
                (*sin).sin_port = addr.port().to_be();
                let ip_bits: u32 = u32::from(*addr.ip()).to_be();
                (*sin).sin_addr.s_addr = ip_bits;
            }
            std::mem::size_of::<libc::sockaddr_in>()
        }
        SocketAddr::V6(_addr) => {
            return Err(anyhow::anyhow!("IPv6 UDP spoofing not yet implemented"))
        }
    };

    let mut iov = libc::iovec {
        iov_base: data.as_ptr() as *mut libc::c_void,
        iov_len: data.len(),
    };

    let mut control_buf = [0u8; 64];
    let mut controllen = 0;

    if let SocketAddr::V4(addr) = spoof_src {
        let cmsg_space =
            unsafe { libc::CMSG_SPACE(std::mem::size_of::<libc::in_pktinfo>() as u32) };
        controllen = cmsg_space as usize;

        unsafe {
            let cmsg = control_buf.as_mut_ptr() as *mut libc::cmsghdr;
            (*cmsg).cmsg_level = libc::SOL_IP;
            (*cmsg).cmsg_type = libc::IP_PKTINFO;
            (*cmsg).cmsg_len = libc::CMSG_LEN(std::mem::size_of::<libc::in_pktinfo>() as u32) as _;

            let pkt_info_ptr = libc::CMSG_DATA(cmsg) as *mut libc::in_pktinfo;
            let mut pkt_info: libc::in_pktinfo = std::mem::zeroed();
            pkt_info.ipi_spec_dst.s_addr = u32::from(*addr.ip()).to_be();
            std::ptr::write(pkt_info_ptr, pkt_info);
        }
    }

    let msg = libc::msghdr {
        msg_name: &mut msg_name as *mut _ as *mut libc::c_void,
        msg_namelen: msg_namelen as u32,
        msg_iov: &mut iov,
        msg_iovlen: 1,
        msg_control: if controllen > 0 {
            control_buf.as_mut_ptr() as *mut libc::c_void
        } else {
            std::ptr::null_mut()
        },
        msg_controllen: controllen as _,
        msg_flags: 0,
    };

    unsafe {
        let n = libc::sendmsg(fd, &msg, 0);
        if n < 0 {
            return Err(std::io::Error::last_os_error().into());
        }
    }

    Ok(())
}

unsafe fn sockaddr_to_socketaddr(storage: &libc::sockaddr_storage) -> Option<SocketAddr> {
    match storage.ss_family as libc::c_int {
        libc::AF_INET => {
            let addr: &libc::sockaddr_in = &*(storage as *const _ as *const libc::sockaddr_in);
            let ip = Ipv4Addr::from(u32::from_be(addr.sin_addr.s_addr));
            Some(SocketAddr::V4(SocketAddrV4::new(
                ip,
                u16::from_be(addr.sin_port),
            )))
        }
        libc::AF_INET6 => {
            let addr: &libc::sockaddr_in6 = &*(storage as *const _ as *const libc::sockaddr_in6);
            let ip = std::net::Ipv6Addr::from(addr.sin6_addr.s6_addr);
            Some(SocketAddr::V6(SocketAddrV6::new(
                ip,
                u16::from_be(addr.sin6_port),
                addr.sin6_flowinfo,
                addr.sin6_scope_id,
            )))
        }
        _ => None,
    }
}

fn get_orig_dst_from_msg(msg: &libc::msghdr) -> Option<SocketAddr> {
    let mut cmsg = unsafe { libc::CMSG_FIRSTHDR(msg) };
    while !cmsg.is_null() {
        let cm = unsafe { &*cmsg };
        if cm.cmsg_level == libc::SOL_IP && cm.cmsg_type == libc::IP_RECVORIGDSTADDR {
            let addr_ptr = unsafe { libc::CMSG_DATA(cmsg) } as *const libc::sockaddr_in;
            let addr = unsafe { &*addr_ptr };
            let ip = Ipv4Addr::from(u32::from_be(addr.sin_addr.s_addr));
            return Some(SocketAddr::V4(SocketAddrV4::new(
                ip,
                u16::from_be(addr.sin_port),
            )));
        }
        cmsg = unsafe { libc::CMSG_NXTHDR(msg, cmsg) };
    }
    None
}

fn get_original_dst(fd: std::os::unix::io::RawFd) -> std::io::Result<SocketAddr> {
    let mut addr: libc::sockaddr_in = unsafe { std::mem::zeroed() };
    let mut len = std::mem::size_of::<libc::sockaddr_in>() as libc::socklen_t;

    let ret = unsafe {
        libc::getsockopt(
            fd,
            libc::SOL_IP,
            libc::SO_ORIGINAL_DST,
            &mut addr as *mut _ as *mut libc::c_void,
            &mut len,
        )
    };

    if ret < 0 {
        return Err(std::io::Error::last_os_error());
    }

    let ip = Ipv4Addr::from(u32::from_be(addr.sin_addr.s_addr));
    Ok(SocketAddr::V4(SocketAddrV4::new(
        ip,
        u16::from_be(addr.sin_port),
    )))
}
